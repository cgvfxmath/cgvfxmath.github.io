---
layout: post
title: "NDK (Nuke Developer Kit)"
author: "wano"
excerpt_separator: <!--more-->
tags: ['dev', 'nuke']
use_math: true
lastmode: 2023-03-27 00:00:00
sitemap:
  changefreq: weekly
  priority: 0.5
---

NUKE NDK is a collection of developer tools that can be used in the digital compositing software NUKE.<!--more-->

NUKE is a non-destructive, node-based (procedural), <strong>32-bit float</strong>, multi-channel, scanline, image compositing system using its own image processing graph (usually called Node Graph or DAG). (In addition to the <strong>scanline-based 2D image system</strong> there are also a number of sub-system available, such as 3D system, deep image compositing system, and particle system.)

NUKE's 2D architecture is largely defined by the <span style="color: #0000ff;"><strong>Iop</strong></span> class, which is the base class for all the image operators. <span style="color: #0000ff;"><strong>Iop</strong></span> specifically defines how NUKE's channel system works, how region of interest and regions of definition are passed up and down the tree, how 2D data is cached, and how bounding box and image formats are dealt with. Several pure virtual functions must be defined by a inherited subclass.

As described above, NUKE is a scanline based system. This means that according to NUKE the fundamental unit for image processing is a scanline. The scanline is one horizontal line of the image. In the <strong>NDK (Nuke Developer Kit)</strong> a scanline is known as a <span style="color: #0000ff;"><strong>Row</strong></span>. This architecture is the main reason NUKE can deal with almost unlimited image sizes. Because image processing is limited to <span style="color: #0000ff;"><strong>Row</strong></span>-size chunks, the whole image does not need to reside in the computer memory at once.

When displaying a large image on the Viewer screen, there are typically less&nbsp;<span style="color: #0000ff;"><strong>Row</strong></span>s displayed on the screen than actual <span style="color: #0000ff;"><strong>Row</strong></span>s in the full image. The NUKE Viewer does not ask its input for every&nbsp;<span style="color: #0000ff;"><strong>Row</strong></span> to produce the output image, as they are not required for display on the screen. In other words, the Viewer skips <span style="color: #0000ff;"><strong>Row</strong></span>s.&nbsp;This is one of the reasons NUKE is fast and interactive even when dealing with large image sizes. This strategy for dealing with large image sizes also means that&nbsp;<span style="color: #0000ff;"><strong>Row</strong></span>s are always computed at full resolution horizontally. Once they are computed, they are correct no matter what the zoom level on the image in the Viewer. In other word when the user zooms in, the Viewer only needs to ask its inputs for&nbsp;<span style="color: #0000ff;"><strong>Row</strong></span>s it hasn't asked for yet.

When producing the output image, the output node typically runs multiple threads to fetch multiple&nbsp;<span style="color: #0000ff;"><strong>Row</strong></span>s from its input at the same time. NUKE has internal synchronization that guarantees only one thread is operating on one&nbsp;<span style="color: #0000ff;"><strong>Row</strong></span>&nbsp;of one node at a time.

Typically when doing image processing, when some nodes are asked to produce their&nbsp;<span style="color: #0000ff;"><strong>Row</strong></span>&nbsp;of output, they actually need more than one&nbsp;<span style="color: #0000ff;"><strong>Row</strong></span>&nbsp;of input to produce the output&nbsp;<span style="color: #0000ff;"><strong>Row</strong></span>. For instance, a&nbsp;<span style="color: #0000ff;"><strong>Box Blur</strong></span>&nbsp;may need many input&nbsp;<span style="color: #0000ff;"><strong>Row</strong></span>s for each output&nbsp;<span style="color: #0000ff;"><strong>Row</strong></span>. In order to avoid computing the same&nbsp;<span style="color: #0000ff;"><strong>Row</strong></span>s multiple times, NUKE generally creates a cache for those&nbsp;<span style="color: #0000ff;"><strong>Row</strong></span>s. When a node asks for the same&nbsp;<span style="color: #0000ff;"><strong>Row</strong></span>, it is returned from the cache instead of being computed again.

Often when performing image calculations, your image processing engine needs to access more than just one&nbsp;<span style="color: #0000ff;"><strong>Row</strong></span>&nbsp;from its input to produce its output&nbsp;<span style="color: #0000ff;"><strong>Row</strong></span>. In order to do that, NUKE has a concept of a&nbsp;<span style="color: #0000ff;"><strong>Tile</strong></span>. A&nbsp;<span style="color: #0000ff;"><strong>Tile</strong></span>&nbsp;has accessor functions on it that allow you to access pixels as a 2-dimensional array of the given&nbsp;<span style="color: #0000ff;"><strong>Tile</strong></span>&nbsp;size. It is important to note that the fundamental unit of image processing in NUKE is still a&nbsp;<span style="color: #0000ff;"><strong>Row</strong></span>. When a&nbsp;<span style="color: #0000ff;"><strong>Tile</strong></span>&nbsp;is created for an input <strong><span style="color: #0000ff;">Op</span></strong>, a cache is created (if one doesn't exist already), and then NUKE fills the&nbsp;<span style="color: #0000ff;"><strong>Row</strong></span>s required on that input&nbsp;<strong><span style="color: #0000ff;">Op</span></strong>&nbsp;to fill the&nbsp;<span style="color: #0000ff;"><strong>Tile</strong></span>. Those&nbsp;<span style="color: #0000ff;"><strong>Row</strong></span>s are then locked in the NUKE cache for the existence for the&nbsp;<span style="color: #0000ff;"><strong>Tile</strong></span>&nbsp;object. You can then use accessor functions on the&nbsp;<span style="color: #0000ff;"><strong>Tile</strong></span>&nbsp;into the internal&nbsp;<span style="color: #0000ff;"><strong>Row</strong></span>s in the cache for that input.

NUKE handles image colors as channels. A channel describe one floating-point component of all pixels in an image. Multiple channels make a channel set (sometimes called a layer).

There is another cache in NUKE in addition to the&nbsp;<span style="color: #0000ff;"><strong>Row</strong></span>&nbsp;cache. This is called the <strong>Viewer cache</strong> and is also described in the Preferences and the user interface as the <strong>disk cache</strong>. The <strong>Viewer cache</strong> is a file written to your disk for each frame as it is displayed in the Viewer. The&nbsp;<strong>Viewer cache</strong>&nbsp;file is not used for image processing and is separate to the <strong>Row cache</strong>. Its primary purpose is the quick display of images in the Viewer for playback and viewing. Because it's written to disk, it survives between runs of NUKE. When the Viewer as an output node needs to produce an output image for display, it first checks to see if any&nbsp;<span style="color: #0000ff;"><strong>Row</strong></span>s that it needs to display are already in the&nbsp;<strong>Viewer cache</strong>&nbsp;on disk. If they are, it simply displays them rather than asks its input for the&nbsp;<span style="color: #0000ff;"><strong>Row</strong></span>s. If any&nbsp;<span style="color: #0000ff;"><strong>Row</strong></span>s are missing from the cache, the Viewer asks its input fro them as usual. So if you run NUKE after modifying your code when you create your own node, the results of the previous state appear in the Viewer instead of the new results. When you encounter this problem, do not panic. Move the mouse cursor over the Viewer area will refresh the Viewer.

reference) https://learn.foundry.com/nuke/developers

